# java 垃圾回收器

##1. parnew 垃圾回收器

1. parnew的多线程是几个线程默认是是CPU数量一样的 -XX:ParallelGCThreads 这个参数可以设置你用多少个线程
2. 多线程好还是单线程好，看CPU数量啦

## 2. cms 垃圾回收器

1. 使用的算法是标记清理算法

2. 垃圾回收的4个阶段（为了垃圾回收和工作线程尽量同时执行）

   1. 初始标记（仅仅标记出来所有的GCroots）
   2. 并发标记（GCroots 追踪 看看其他被引用的对象）这个时候是可以创建新的对象的
   3. 重新标记  （对第二个阶段创建的垃圾对象进行标记）
   4. 并发清除  清除所有标记出来的垃圾对象。

3. cms的回收问题

   1. 并发回收导致CPU资源紧张（默认线程数量是（CPU核数 + 3）/ 4）
   2. **Concurrent Mode Failure问题**  浮动垃圾问题 在并发清理阶段出现的没引用的对象 默认会给老年代8%的浮动垃圾空间 如果这个百分之八没有担保成功会替换成serial old 进行老年代垃圾回收
   3. XX:+UseCMSCompactAtFullCollection 整理工作默认打开是在垃圾回收以后进行垃圾的整理 XX:CMSFullGCsBeforeCompaction设置多少次垃圾回收进行一次整理默认是0，每次都整理
     

   ## 3.新生代垃圾回收优化

   	1. survivor 区太小
    	2. 指定垃圾回收器
    	3. 指定多大的对象直接进入老年代

   ## parnew和cms的组合有什么问题

   1. 最大的问题就是stw不太好控制

   ## G1垃圾回收器上场了

   1. Java堆先拆分成多个大小相等的region
   2. 新生代老年代依然保留，不过只是逻辑上的概念
   3. G1给我们的最大的特点是什么呢？是可预期的停顿时间
   4. 根据预估当前region的可回收的内存大小和预估的回收时间来达到控制停顿时间的目的
   5. region属于新生代和老年代不是固定不变的，region是属于老年代还是新生代是由G1自己控制的不需要设置给老年代多大内存新生代多大内存

   

   ## G1回收器为什么会比传统的回收器性能好

   1. G1有多少个region呢？最多有2048个，每个region必须是2的倍数，如果1M2M等
   2. -XX:G1HeapRegionSize 这个可以指定region的大小，刚开始的时候默认新生代有5%的region
   3. “-XX:G1NewSizePercent 这个可以设置开始的新生代的region的比例一般默认即可，**新生代最多不会超过60% -XX:G1MaxNewSizePercent 这个可用于设置最大的比例。这个比例是动态的**
   4. G1收集器中的新生代老年代和**Eden以及survivor都是存在的只是不同的region而已。**
   
5. G1的新生代垃圾回收是等新生代的region占比达到百分之六十或者是设定的值，而且Eden区已经满了，才发生的垃圾回收。**-XX:MaxGCPauseMills 这个可以用来设置目标的停顿时间**
   6. 大对象region，一个对象只要超过一个region的一半就会放置到大对象region中。一个大对象是可以跨region存放的。在新生代和老年代回收的时候，都会顺带着回收大对象的region

   

   ## G1回收器的回收过程

   1. “-XX:InitiatingHeapOccupancyPercent” 这个可以设置老年代达到这个比例的时候发生新生代和老年代的混合回收。默认是45%
   
2. 回收步骤如下:
      1. 初始标记（标记gc roots） stw
      2. 并发标记（Gc roots 追踪）
      3. 最终标记（标记浮动垃圾和根据上一阶段修改的变化对象的状态修改）stw
      4. 混合回收（计算回收的预期性能和效率）然后停止程序，全力回收。根据我们设置的预期性能，尽量多的回收垃圾（也就是Mixed GC）。**一次回收是可以有多个混合回收的过程** **默认8次**这样可以达到预期的回收停顿  -XX:G1HeapWastePercent 混合回收都是复制算法，如果空闲的region超过了设置的比例就停止混合回收  **-XX:G1MixedGCLiveThresholdPercent** 回收的时候存活对象低于这个值才去回收这个region **默认是85%**
   3. 混合回收失败以后的 full gc，因为混合回收都是复制算法，所以需要有空闲的region，来存放存活的对象，如果没有空闲的region了就失败了。一旦失败就立刻切换为单线程回收，并停止程序。
   
   
   
   ## 垃圾回收的名词解释
   
   1. Minor GC、Young GC 都是年轻代GC
   2. **Full GC？Old GC？**  都是老年代GC
   3. **Full GC** 指的是针对新生代、老年代、永久代的全体内存空间的垃圾回收，所以称之为Full GC
   4. **Major GC** 有人说是和full gc 等价的
   5. **Mixed GC** 是G1收集器的特有混合GC的方式
   
   
   
    **G1 Java垃圾收集器更适用于大内存机器**，因为设置的预期的垃圾收集性能。可以只回收一部分eden。young gc的问题并不大，但是如果内存很大的话，就是容易停顿时间过长。
   
   
   
   在垃圾收集的时候，如果survivor区放不下对应的存活对象，可能会一部分进入老年代，一部分进入survivor的。
   
   
   
   
   
   
   
   
   
   
   
   