# jvm的基本运行和类加载的简单流程

1. Java代码的基本运行原理

   ![image-20191122151313069](../../images/image-20191122151313069.png)
   可以看到我们需要一个类加载器来加载我们的类进入到jvm，然后才可以运行。

2. jvm 什么情况会加载一个类？类加载的过程

   1. 类的加载到使用过程一般有以下几个步骤：**加载、验证、准备、解析、初始化、使用、卸载**
   2. 什么时候会加载这个类呢？简单说就是什么时候用到了就加载(**懒加载**)

   **验证阶段：**主要是验证以下是否符合我们的jvm要求比如版本等只有符合我们规范的才可以进入到jvm使用

   **准备阶段：**给对应的class分配空间，然后给**静态变量赋初始值**

   **解析阶段：**符号引用替换为直接引用的过程

   **<font color='red'>初始化阶段：</font>**
   ![image-20191122152250049](../../images/image-20191122152250049.png)
   这个阶段很重要：比如说 int类型的值在准备阶段只是给一个Java的默认值0，而不是配置中的数字，这个一个阶段就会赋值成对应的配置结果。**初始化规则必须先初始化父类**加载器不在这里赘述

   类初始化的时机：

    1.当创建某个类的新实例时（如通过new或者反射，克隆，反序列化等）

    2.当调用某个类的静态方法时

    3.当使用某个类或接口的静态字段时

    4.调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时

    5.当初始化某个子类时

    6.当虚拟机启动某个被标明为启动类的类（即包含main方法的那个类） 所以System.ou.println(Test.class)不满足上面6种情况，也就没有做初始化

# Tomcat 的类加载特殊之处和Java的内存分区

1. 存放类的方法区，在jdk1.8以前名字叫方法去，1.8以后改名字了，Metaspace(元数据空间)。
2. 存放代码运行位置的程序计数器
3. 存放Java内部方法的Java 虚拟机栈
4. 存放对象的Java堆
5. Java本地方法的 本地方法栈
6. Java的堆外内存(allocateDirect 这种方法)

![image-20191122153843510](../../images/image-20191122153843510.png)
Tomcat 打破了双亲委派模型，自己的web应用有底层加载器直接加载。

# java 垃圾回收开启 Java对象有多大

1. 对象大小主要有两部分**对象头和对象的实例数据**对象头一般是16字节
2. Java的 class什么时候回收
   1. 没有这个class的对象
   2. 加载这个class的classloader 已经被回收了，不可能通过其他的方式增加对象了



# Java 对象的晋升机制

1. 动态年龄判断机制（年龄1+年龄2+年龄n的多个年龄对象总和超过了一个Survivor区的一半，超过n的就晋升）
2. 指定年龄机制（15次）-XX:MaxTenuringThreshold 这个参数可以设置
3. 大对象机制 -XX:PretenureSizeThreshold 这个参数可以指定超过多大的对象直接进入老年代
4. 空间担保机制 **如果一个minor gc 剩余的对象超过一个survivor区的大小，那么这部分的对象全部进入老年代** 如果设置了HandlePromotionFailure 参数，发生minorGc 以前会判断 老年代的空间大小是不是超过每次minor Gc进入老年代的平均大小。如果小于这个值就进行一次老年代GC，然后进行minor gc。如果老年代gc以后发现剩余的空间还是不足存放新生代活着的对象就直接oom。如果没有这设置这个参数就会看老年代的空间是否大于新生代所有对象的空间大小



# Java 系统的元数据空间大小怎么设置

1. 一般几百M TODO增加案例分析
2. 栈内存一般1M到512Kb都可以的



# Java 什么样的对象是不可以被回收的

1. 静态变量(或者常量)或者是局部变量(虚拟机栈和本地方法栈)引用的对选是不可以被回收的。
2. Java中引用的类型
   1. 强引用类型（new 出来的对象被栈帧或者其他的引用）是肯定不可以被回收的
   2. 软引用 （softReference）如果内存实在不够是可以被回收的（发生垃圾回收可能会被回收也可能不会被回收）**如果垃圾回收以后空间还是不足，就开始回收软引用了**
   3. 弱引用（weakReference）发生垃圾回收就会把这个对象回收掉
   4. 虚引用(todo)
3. Finalize 方法的作用， 可以在对象回收前调用一下这个方法（虚拟机自己调用，你写好就可以了）让自己被一个GC roots引用就可以不被回收了，就是拯救一下自己



# Java 虚拟机垃圾回收算法的比较

1. 年轻代的垃圾回收算法有一块 Eden区和两块survivor区，为了提升内存的利用率，每次都有一块空间是空着的好实用复制算法
2. 老年代触发垃圾回收的时机
   1. minor 当设置了空间担保参数 会分为两种情况（<font color='red'>ps:jdk 1.7以后老年代空间老年代可用空间”> “新生代对象总和”，或者“老年代可用空间”> “历次Minor GC升入老年代对象的平均大小就不用进行老年代的gc，先进行minor GC </font>）
      1. 不进行担保老年代剩余空间小于新生代全部存活对象，
      2. 进行担保，但是小于平均每次晋升上来的对象的大小
   2. 在minor gc 以后发现剩余的内存不足存放，新晋升的对象，发生的GC。
   3. XX:CMSInitiatingOccupancyFaction cms的垃圾回收参数，超过这个比例开始老年代回收，默认是92%
3. 老年代的GC算法
   1. 标记整理算法 标记以后清除垃圾对象，是否需要整理可以设置一个参数。可以多次回收进行一次整理，也可以每次都整理



# java 垃圾回收器

1. serial 是回收新生代的垃圾回收器，单线程
2. serial old 是回收老年代的垃圾回收期，单线程
3. parnew 是回收新生代的多线程垃圾回收器
4. cms是回收老年代的多线程垃圾回收器。
5. G1收集器统一回收新生代和老年代的垃圾回收器



